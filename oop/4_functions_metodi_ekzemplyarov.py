class Person:
    def hello():
        print("Hello")


print(Person.hello)  # обратимся к функции метода без ее вызова (без скобочек) результат будет что этоф ункция

p = Person()  # создадим экземпляр

print(p.hello)  # обратимся к функции экземпляра и увидим в результате не функцию, а баунд метод
print(hex(id(
    p)))  # атрибут hello у переменной p которая является экземпляром класса Person является связанным методом с объектом hello у класса person.

# и их поведение отличается:

Person.hello()  # получим при вызове строку
# p.hello() # получим исключение, что передан аргумент

# посмотрим их типы:
print(type(Person.hello))  # тип функция
print(type(p.hello))  # тип метод
# т.е. функции и методы это разные классы.
# Функция класса при создании метода трансформируется в другой объект, метод. И связывается с созданным экземпляром класса.
# т.е. метод взывает функцию и передает туда имя экземпляра Person.hello(p)

print(p.hello.__self__)  # Свойство __self__ передает как раз объект p т.е. ссылка на экземпляр класса p
print(hex(id(p)))

print(p.hello.__func__)  # ссылка на функцию function Person.hello куда будет передаваться экземпляр класса


# т.е. мы должны учитывать что при вызове метода туда будет передаваться экземпляр класса

# например
class Person:
    def hello(instance):
        print(instance)


p = Person()
p.hello()
print(hex(id(p)))


# По соглашению этот первый параметр экземпляра класса называется self т.к. это ссылка на самого себя

class Person:
    def hello(self):
        print(self)


p = Person()
p.hello()
print(hex(id(p)))
